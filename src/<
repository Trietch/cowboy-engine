#include "Sphere.h"

#include <iostream>

Sphere::Sphere(glm::vec3 position, glm::vec3 rotation, glm::vec3 scale, glm::vec2 faces)
		: Shape(
			position,
			rotation,
			scale,
			generate_vertices(faces),
			std::vector<GLfloat>{
				0,		1,		0,
				1,		0,		1,
			},
			generate_indices(faces),
			"sphere"	
		)
		, _shader {
			"../src/shaders/triangle.vert",
			"../src/shaders/triangle.frag"
		}
		, _color {0.0f, 0.0f, 1.0f, 1.0f}
{

}

std::vector<GLfloat> Sphere::generate_vertices(glm::vec2 faces) {
	/*
	std::vector<GLfloat> vertices;
	float x, y, z, xy;
	//float nx, ny, nz;

	unsigned int longitude_count = faces[0];
	unsigned int latitude_count = faces[1];

	float longitude_step = 2*glm::pi<float>() / longitude_count;
	float latitude_step = glm::pi<float>() / latitude_count;
	float longitude_angle, latitude_angle;

	for (unsigned int i = 0; i <= latitude_count; ++i) {
		latitude_angle = glm::pi<float>() / 2 - i * latitude_step;
		xy = cosf(latitude_angle); 
		z = sinf(latitude_angle); 
		for (unsigned int j = 0; j <= longitude_count; ++j) {
			longitude_angle = j*longitude_step;

			x = xy * cosf(longitude_angle);
			y = xy * sinf(longitude_angle);

			vertices.push_back(x);
			vertices.push_back(y);
			vertices.push_back(z);
		}
	}
	return vertices;
	*/
	const float PI = 3.1415926f;
	const float H_ANGLE = PI / 180 * 72;    // 72 degree = 360 / 5
	const float V_ANGLE = atanf(1.0f / 2);  // elevation = 26.565 degree
	std::vector<float> vertices(12 * 3);    // array of 12 vertices (x,y,z)
	int i1, i2;                             // indices
	float z, xy;                            // coords
	float hAngle1 = -PI / 2 - H_ANGLE / 2;  // start from -126 deg at 1st row
	float hAngle2 = -PI / 2;                // start from -90 deg at 2nd row

	// the first top vertex at (0, 0, r)
	vertices[0] = 0;
	vertices[1] = 0;
	vertices[2] = radius;
	// compute 10 vertices at 1st and 2nd rows
	for(int i = 1; i <= 5; ++i)
	{
		i1 = i * 3;         // index for 1st row
		i2 = (i + 5) * 3;   // index for 2nd row
		z  = radius * sinf(V_ANGLE);            // elevaton
		xy = radius * cosf(V_ANGLE);            // length on XY plane
		vertices[i1] = xy * cosf(hAngle1);      // x
		vertices[i2] = xy * cosf(hAngle2);
		vertices[i1 + 1] = xy * sinf(hAngle1);  // y
		vertices[i2 + 1] = xy * sinf(hAngle2);
		vertices[i1 + 2] = z;                   // z
		vertices[i2 + 2] = -z;
		// next horizontal angles
		hAngle1 += H_ANGLE;
		hAngle2 += H_ANGLE;
	}
	// the last bottom vertex at (0, 0, -r)
	i1 = 11 * 3;
	vertices[i1] = 0;
	vertices[i1 + 1] = 0;
	vertices[i1 + 2] = -radius;
	return vertices;
}

std::vector<GLuint> Sphere::generate_indices(glm::vec2 faces) {
	std::vector<GLuint> indices;
	int k1, k2;
	unsigned int longitude_count = faces[0];
	unsigned int latitude_count = faces[1];

	for (unsigned int i = 0; i < latitude_count; ++i) {
		k1 = i * (longitude_count+1);
		k2 = k1 + longitude_count + 1;

		for (unsigned int j = 0; j < longitude_count; ++j, ++k1, ++k2) {
			if (i != 0) {
				indices.push_back(k1);
				indices.push_back(k2);
				indices.push_back(k1+1);
			}
			if (i != latitude_count-1) {
				indices.push_back(k1+1);
				indices.push_back(k2);
				indices.push_back(k2+1);
			}
		}
	}
	return indices;
}

Sphere::~Sphere() {
	
}

void Sphere::draw(glm::vec3 view_position, glm::mat4 projection, float delta_time) {
	_shader.use();
	apply_color();

	rotate_test(delta_time);

	_shader.set_mat4("model", get_model());
	_shader.set_mat4("view", get_view(view_position));
	_shader.set_mat4("projection", projection);

	draw_vertex();
}

void Sphere::apply_color() {
	_shader.set_4f("_color", _color);
}

